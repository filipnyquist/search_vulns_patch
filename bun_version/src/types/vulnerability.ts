/**
 * Enum representing the reason why a vulnerability was matched
 */
export enum MatchReason {
  PRODUCT_MATCH = 'product_match',
  VERSION_IN_RANGE = 'version_in_range',
  GENERAL_PRODUCT_OK = 'general_product_ok',
  DESCRIPTION_MATCH = 'description_match',
  GENERAL_PRODUCT_UNCERTAIN = 'general_product_uncertain',
  SINGLE_HIGHER_VERSION = 'single_higher_version',
  VULN_ID = 'vuln_id',
  N_A = 'n_a',
}

/**
 * Priority mapping for match reasons (higher is better)
 */
const MATCH_REASON_PRIORITY: Record<MatchReason, number> = {
  [MatchReason.PRODUCT_MATCH]: 8,
  [MatchReason.VERSION_IN_RANGE]: 7,
  [MatchReason.GENERAL_PRODUCT_OK]: 6,
  [MatchReason.DESCRIPTION_MATCH]: 5,
  [MatchReason.GENERAL_PRODUCT_UNCERTAIN]: 4,
  [MatchReason.SINGLE_HIGHER_VERSION]: 3,
  [MatchReason.VULN_ID]: 2,
  [MatchReason.N_A]: 1,
};

export function getMatchReasonPriority(reason: MatchReason): number {
  return MATCH_REASON_PRIORITY[reason] || 1;
}

export function compareMatchReasons(a: MatchReason, b: MatchReason): number {
  return getMatchReasonPriority(a) - getMatchReasonPriority(b);
}

/**
 * Represents a software vulnerability
 */
export class Vulnerability {
  id: string;
  matchReason: MatchReason;
  matchSources: string[];
  description: string;
  published: string;
  modified: string;
  cvssVer: string;
  cvss: string;
  cvssVec: string;
  exploits: Set<string>;
  cisaKnownExploited: boolean;
  aliases: Record<string, string>;
  trackedBy: string[];
  epss: string;
  reportedPatchedBy: string[];
  misc: Record<string, any>;

  constructor(params: {
    id: string;
    matchReason: MatchReason;
    matchSources: string | string[];
    description?: string;
    published?: string;
    modified?: string;
    cvssVer?: string;
    cvss?: string;
    cvssVec?: string;
    exploits?: string[];
    cisaKnownExploited?: boolean;
    href?: string;
    aliases?: Record<string, string>;
    trackedBy?: string[];
    epss?: string;
    reportedPatchedBy?: string[];
    [key: string]: any;
  }) {
    if (!params.id) {
      throw new Error('Vuln ID cannot be None');
    }
    if (!params.matchReason) {
      throw new Error('Vuln match_reason cannot be None');
    }
    if (!params.matchSources) {
      throw new Error('Vuln match_sources cannot be None');
    }

    this.id = params.id;
    this.matchReason = params.matchReason;
    this.matchSources = Array.isArray(params.matchSources)
      ? [...params.matchSources]
      : [params.matchSources];
    this.description = params.description || '';
    this.published = params.published || '';
    this.modified = params.modified || '';
    this.cvssVer = params.cvssVer || '';
    this.cvss = params.cvss || '';
    this.cvssVec = params.cvssVec || '';
    this.exploits = new Set(params.exploits || []);
    this.cisaKnownExploited = params.cisaKnownExploited || false;
    this.aliases = params.aliases || {};
    this.trackedBy = params.trackedBy || [];
    this.epss = params.epss || '';
    this.reportedPatchedBy = params.reportedPatchedBy || [];

    // Add primary ID and href to aliases if provided
    if (this.id && !(this.id in this.aliases)) {
      this.aliases[this.id] = params.href || '';
    }

    // Store any additional properties in misc
    this.misc = {};
    const knownProps = [
      'id',
      'matchReason',
      'matchSources',
      'description',
      'published',
      'modified',
      'cvssVer',
      'cvss',
      'cvssVec',
      'exploits',
      'cisaKnownExploited',
      'href',
      'aliases',
      'trackedBy',
      'epss',
      'reportedPatchedBy',
    ];
    for (const [key, value] of Object.entries(params)) {
      if (!knownProps.includes(key)) {
        this.misc[key] = value;
      }
    }
  }

  /**
   * Merge this vulnerability with another
   */
  mergeWithVulnerability(other: Vulnerability): void {
    // Merge based on match reason priority
    if (compareMatchReasons(other.matchReason, this.matchReason) > 0) {
      // Other has higher priority, use its primary attributes
      this.id = other.id;
      this.matchReason = other.matchReason;
      this.description = other.description || this.description;
      this.published = other.published || this.published;
      this.modified = other.modified || this.modified;
      this.cvssVer = other.cvssVer || this.cvssVer;
      this.cvss = other.cvss || this.cvss;
      this.cvssVec = other.cvssVec || this.cvssVec;
    }

    // Merge collections
    this.matchSources = Array.from(new Set([...this.matchSources, ...other.matchSources]));
    this.trackedBy = Array.from(new Set([...this.trackedBy, ...other.trackedBy]));
    this.reportedPatchedBy = Array.from(
      new Set([...this.reportedPatchedBy, ...other.reportedPatchedBy])
    );

    for (const exploit of other.exploits) {
      this.exploits.add(exploit);
    }

    // Merge aliases
    for (const [alias, href] of Object.entries(other.aliases)) {
      if (!(alias in this.aliases)) {
        this.aliases[alias] = href;
      }
    }

    // Update misc
    for (const [key, value] of Object.entries(other.misc)) {
      if (!(key in this.misc)) {
        this.misc[key] = value;
      }
    }

    // Use other's values if they're set and ours aren't
    this.cisaKnownExploited = this.cisaKnownExploited || other.cisaKnownExploited;
    this.epss = this.epss || other.epss;
  }

  /**
   * Check if the vulnerability has been patched
   */
  isPatched(): boolean {
    return this.reportedPatchedBy.length > 0;
  }

  /**
   * Convert to a plain object for JSON serialization
   */
  toDict(): Record<string, any> {
    return {
      id: this.id,
      match_reason: this.matchReason,
      match_sources: this.matchSources,
      description: this.description,
      published: this.published,
      modified: this.modified,
      cvss_ver: this.cvssVer,
      cvss: this.cvss,
      cvss_vec: this.cvssVec,
      exploits: Array.from(this.exploits),
      cisa_known_exploited: this.cisaKnownExploited,
      aliases: this.aliases,
      tracked_by: this.trackedBy,
      epss: this.epss,
      reported_patched_by: this.reportedPatchedBy,
      ...this.misc,
    };
  }
}

/**
 * Search result type
 */
export interface SearchVulnsResult {
  product_ids: Record<string, string[]>;
  vulns: Record<string, Vulnerability>;
  pot_product_ids: Record<string, any[]>;
  [key: string]: any;
}
